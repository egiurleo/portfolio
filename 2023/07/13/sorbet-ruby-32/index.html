<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Making Sorbet compatible with Ruby 3.2 | Emily Samp</title>

<meta name="description" content="The website of Emily Samp, a software developer and community organizer." />

<link rel="stylesheet" href="/_bridgetown/static/index.XPTEAHIP.css" />
<script src="/_bridgetown/static/index.RARUY3ZT.js" defer></script>
<script type="module">let lastmod = 0
function startReloadConnection() {
  const evtSource = new EventSource("/_bridgetown/live_reload")
  evtSource.onmessage = event => {
    if (document.querySelector("#bridgetown-build-error")) document.querySelector("#bridgetown-build-error").close()
    if (event.data == "reloaded!") {
      location.reload()
    } else {
      const newmod = Number(event.data)
      if (lastmod > 0 && newmod > 0 && lastmod < newmod) {
        location.reload()
      } else {
        lastmod = newmod
      }
    }
  }
  evtSource.addEventListener("builderror", event => {
    let dialog = document.querySelector("#bridgetown-build-error")
    if (!dialog) {
      dialog = document.createElement("dialog")
      dialog.id = "bridgetown-build-error"
      dialog.style.borderColor = "red"
      dialog.style.fontSize = "110%"
      dialog.innerHTML = `
        <p style="color:red">There was an error when building the site:</p>
        <output><pre></pre></output>
        <p><small>Check your Bridgetown logs for further details.</small></p>
      `
      document.body.appendChild(dialog)
      dialog.showModal()
    }
    dialog.querySelector("pre").textContent = JSON.parse(event.data)
  })
  evtSource.onerror = event => {
    if (evtSource.readyState === 2) {
      // reconnect with new object
      evtSource.close()
      console.warn("Live reload: attempting to reconnect in 3 seconds...")

      setTimeout(() => startReloadConnection(), 3000)
    }
  }
}
setTimeout(() => {
  startReloadConnection()
}, 500)
</script>

 %>

<base target="_blank" rel="noopener noreferrer">

<link
  rel="stylesheet"
  href="https://fonts.googleapis.com/css?family=Josefin+Sans:300,400,500,600,700&display=swap"
/>

<link
  rel="stylesheet"
  href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,500,600,700&display=swap"
/>

  </head>
  <body class="post ">
    <header>
  <span class="title">Emily Samp</span>

  <nav>
    <ul>
      <li><a href="/" target="_self">Home</a></li>
      <li><a href="/blog" target="_self">Blog</a></li>
      <li><a href="/talks" target="_self">Talks</a></li>
      <li><a href="/podcasts" target="_self">Podcasts</a></li>
      <li><a href="/projects" target="_self">Projects</a></li>
    </ul>
  </nav>
</header>


    <main>
      <h1>Making Sorbet compatible with Ruby 3.2</h1>

<p class="post-date">
  July 13, 2023
</p>

<p class="note">
  ⚠️ <strong>Note</strong>: This article is cross-posted from Shopify’s <a href="https://railsatscale.com/2023-06-16-adding-ruby-3-2-support-to-sorbet/">Rails at Scale blog</a>.
</p>

<p>On the Ruby Developer Experience team here at Shopify, our goal is to deliver a state-of-the-art development experience to Rubyists both at Shopify and in the broader community. This means keeping our tools up-to-date with the most recent versions of Ruby.</p>

<p>One such tool is <a href="https://sorbet.org/">Sorbet</a>, which is an open source, gradual type checker for Ruby. Sorbet has become a key part of the development experience at Shopify, making it faster and safer for developers to collaborate on a monolith with tens of thousands of Ruby files.</p>

<p>When we upgraded the Shopify monolith to use Ruby 3.2 at the beginning of 2023, we knew it would require us to make some changes to Sorbet. While upgrading Ruby didn’t break type checking, Sorbet did not yet support all of the <a href="https://www.ruby-lang.org/en/news/2022/12/25/ruby-3-2-0-released/">features introduced in this new Ruby version</a>. If Shopify developers were going to take advantage of the features that came with Ruby 3.2, like the <code class="highlighter-rouge">Data</code> class and anonymous argument forwarding, we would need to make sure Sorbet could accurately type check these usages and report any type checking errors.</p>

<p>This post is a summary of the work we did to make Sorbet compatible with Ruby 3.2.</p>

<h2 id="the-sorbet-pipeline">The Sorbet pipeline</h2>

<p>Sorbet statically type checks our code in a process called the <a href="https://github.com/sorbet/sorbet/blob/master/docs/internals.md#pipeline">“pipeline”</a>. The pipeline is made up of different stages, each of which modifies some internal representation of the code before passing it along to the next stage. The ultimate goal of the pipeline is to convert Ruby code into a representation that enables Sorbet to reason about types and identify type checking errors.</p>

<p>When updating Sorbet to support a new feature in Ruby, it is important to understand which part of the pipeline needs to be changed. When explaining each of the changes my teammates and I implemented, I’ll also give an explanation of the relevant parts of the Sorbet pipeline so you can understand why we approached these problems in the ways we did.</p>

<p>I hope this overview of Sorbet’s architecture might also encourage you to contribute to Sorbet in the future!</p>

<hr />

<h2 id="anonymous-argument-forwarding-and-the-sorbet-parser">Anonymous argument forwarding and the Sorbet parser</h2>

<p>The largest syntax change in Ruby 3.2 was the introduction of <a href="https://bugs.ruby-lang.org/issues/18351">anonymous argument forwarding</a>. This means that in Ruby, it is now possible for a method that takes anonymous arguments or keyword arguments to pass them along to another method, as in this example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
  <span class="n">bar</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">baz</span><span class="p">(</span><span class="o">**</span><span class="p">)</span>
  <span class="n">quux</span><span class="p">(</span><span class="o">**</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="updating-sorbets-parser">Updating Sorbet’s parser</h3>

<p>To support this feature, we first needed to make a change to Sorbet’s parser grammar.</p>

<p>The <a href="https://github.com/sorbet/sorbet/blob/master/docs/internals.md#parser">parser</a> is the first step in the Sorbet pipeline. Its job is to convert Ruby code into an abstract syntax tree, which is then passed through the rest of the pipeline to be processed and eventually type checked. Without updating the parser, Sorbet wouldn’t even be able to recognize anonymous argument forwarding as valid Ruby code and would raise syntax errors, erroneously telling developers they’d made a mistake!</p>

<p>To address this, we opened a <a href="https://github.com/sorbet/sorbet/pull/6910/commits/51808d62a501a97cd60ec6ab9e10aaff821d1e0f">pull request</a> that created two new abstract syntax tree nodes representing anonymous argument forwarding. With this change, Sorbet could now represent anonymous argument forwarding in a way that was usable by the following steps in the type checking pipeline.</p>

<p>We can <a href="https://sorbet.run/?arg=--print&amp;arg=parse-tree#%23%20typed%3A%20true%0A%0Adef%20foo%28*%29%0A%20%20bar%28*%29%0Aend%0A%0Adef%20baz%28**%29%0A%20%20quux%28**%29%0Aend">see the parser at work using sorbet.run</a>, Sorbet’s online sandbox. If we add the URL parameters <code class="highlighter-rouge">?arg=--print&amp;arg=parse-tree</code>, the Sorbet sandbox will print out the results of the parsing step in the pipeline. In these results, we can see that the <code class="highlighter-rouge">bar</code> method receives an argument node of the type <code class="highlighter-rouge">ForwardedRestArg</code>, and the <code class="highlighter-rouge">baz</code> method receives an argument node of the type <code class="highlighter-rouge">ForwardedKwrestArg</code>.</p>

<p>(By the way, if you’re interested in learning more about parsing in Ruby, check out <a href="https://railsatscale.com//2023-06-12-rewriting-the-ruby-parser/">Kevin Newton’s recent blog post</a> about building a new Ruby parser.)</p>

<h3 id="desugaring">Desugaring</h3>

<p>Updating the parser was the first step in allowing Sorbet to process instances of anonymous argument forwarding, but supporting this feature also required changes to another step in the Sorbet pipeline: the desugarer.</p>

<p>The <a href="https://github.com/sorbet/sorbet/blob/master/docs/internals.md#desugar">desugarer</a> is the next step in the Sorbet pipeline after the parser; it takes the internal representation built by the parser and cuts it down to a less granular representation, making it easier to work with in later stages of the pipeline.</p>

<p>To explain what I mean, let’s look at how Sorbet desugars <code class="highlighter-rouge">case</code> statements like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="n">pokemon</span>
<span class="k">when</span> <span class="s1">'Charmander'</span>
<span class="k">when</span> <span class="s1">'Squirtle'</span>
<span class="k">when</span> <span class="s1">'Bulbasaur'</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The Sorbet desugarer will take the above <code class="highlighter-rouge">case</code> statement and transform it into an <code class="highlighter-rouge">if</code> statement:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="s1">'Charmander'</span> <span class="o">===</span> <span class="n">pokemon</span>
<span class="k">elsif</span> <span class="s1">'Squirtle'</span> <span class="o">===</span> <span class="n">pokemon</span>
<span class="k">elsif</span> <span class="s1">'Bulbasaur'</span> <span class="o">===</span> <span class="n">pokemon</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Sorbet does this because it’s simpler to maintain type checking logic for one type of code pattern rather than two. This is why this step of the pipeline is called the “desugarer” – it removes “syntactic sugar,” or syntax that exists only to make the development experience better. If earlier stages of the pipeline can limit the different kinds of syntax Sorbet has to type check, then later stages of the pipeline will contain less type checking logic, making them easier to reason about and maintain.</p>

<p>We applied a similar principle to desugaring anonymous argument forwarding. Rather than implementing an entire new type checking process for <code class="highlighter-rouge">ForwardedRestArg</code> and <code class="highlighter-rouge">ForwardedKwrestArg</code> nodes, we used the desugarer to transform them into a representation that Sorbet already knew how to type check!</p>

<p>Back in 2020, my teammate Alexandre added support for <a href="https://bugs.ruby-lang.org/issues/16253">Ruby 2.7’s “forward everything” syntax</a> to Sorbet (<a href="https://github.com/sorbet/sorbet/pull/3420">PR here</a>). As part of that work, he added logic to the desugarer that would break down forwarded args into three “magic” expressions. As an example, if we had the following code snippet:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">buzz</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
  <span class="n">biz</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The Sorbet desugarer would transform the arguments passed to <code class="highlighter-rouge">biz</code> into something like:</p>

<ul>
  <li><code class="highlighter-rouge">fwd-args</code></li>
  <li><code class="highlighter-rouge">fwd-kwargs</code></li>
  <li><code class="highlighter-rouge">fwd-block</code></li>
</ul>

<p>None of these expressions actually exist in Ruby code – they’re created by the desugarer as a placeholder that Sorbet can type check later on in the pipeline. This is why they’re called “magic.”</p>

<p>You can see this for yourself on <a href="https://sorbet.run/?arg=--print&amp;arg=desugar-tree#%23%20typed%3A%20true%0A%0Adef%20buzz%28...%29%0A%20%20biz%28...%29%0Aend">sorbet.run</a>. In this case, if we add the <code class="highlighter-rouge">?arg=--print&amp;arg=desugar-tree</code> URL parameters, sorbet.run will show us the output of the desugaring stage, including the magic expressions listed above!</p>

<p>Because Ruby 3.2’s anonymous argument forwarding feature is so similar to the forward everything syntax, we were able to lean on the work that Alexandre had already done. We updated the desugarer to desugar <code class="highlighter-rouge">ForwardedRestArg</code> nodes (e.g. the argument of <code class="highlighter-rouge">bar(*)</code>) as magic <code class="highlighter-rouge">fwd-args</code> expressions and <code class="highlighter-rouge">ForwardedKwrestArg</code> nodes (e.g. the arguemnt of <code class="highlighter-rouge">quux(**)</code>) as magic <code class="highlighter-rouge">fwd-kwargs</code> expressions.</p>

<p>You can see how Sorbet desugars anonymous argument forwarding on <a href="https://sorbet.run/?arg=--print&amp;arg=desugar-tree#%23%20typed%3A%20true%0A%0Adef%20foo%28*%29%0A%20%20bar%28*%29%0Aend%0A%0Adef%20baz%28**%29%0A%20%20quux%28**%29%0Aend">sorbet.run</a>.</p>

<p>Once we modified the desugarer to convert forwarded anonymous arguments into a representation that Sorbet already knew how to type check, we could rely on the rest of the pipeline to complete the type checking process!</p>

<p>To see our full set of changes, check out the <a href="https://github.com/sorbet/sorbet/pull/6910">pull request that implements support for anonymous argument forwarding in Sorbet</a>.</p>

<h2 id="supporting-the-new-data-class">Supporting the new <code class="highlighter-rouge">Data</code> class</h2>

<p>Another major change in Ruby 3.2 was addition of the <a href="https://docs.ruby-lang.org/en/3.2/Data.html"><code class="highlighter-rouge">Data</code> class</a>. <code class="highlighter-rouge">Data</code> provides a convenient way to define immutable data structures in Ruby. Here’s an example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Measure</span> <span class="o">=</span> <span class="no">Data</span><span class="p">.</span><span class="nf">define</span><span class="p">(</span><span class="ss">:amount</span><span class="p">,</span> <span class="ss">:unit</span><span class="p">)</span>
<span class="n">distance</span> <span class="o">=</span> <span class="no">Measure</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="s1">'km'</span><span class="p">)</span>
<span class="n">distance</span><span class="p">.</span><span class="nf">amount</span> <span class="c1">#=&gt; 100</span>
<span class="n">distance</span><span class="p">.</span><span class="nf">unit</span> <span class="c1">#=&gt; "km"</span>
</code></pre></div></div>

<p>In this example, calling <code class="highlighter-rouge">Data.define</code> creates a new class that has some methods built into it, including a constructor and <code class="highlighter-rouge">amount</code> and <code class="highlighter-rouge">unit</code> accessor methods. Because these methods are created at runtime, Sorbet wouldn’t be able to know about them statically without a little help. To “teach” Sorbet about these methods, we needed to make a change to a part of the pipeline called the “rewriter.”</p>

<h3 id="adding-a-new-rewriter">Adding a new rewriter</h3>

<p>The stage of the pipeline after the “desugarer” is the “rewriter” stage. <a href="https://github.com/sorbet/sorbet/blob/master/docs/internals.md#rewriter">Rewriters</a> are very similar to the desugarer, but while the desugarer is broad and covers many types of Ruby syntax, rewriters are specific; they each handle a particular Ruby class or feature.</p>

<p>For example, Sorbet’s <a href="https://github.com/sorbet/sorbet/blob/master/rewriter/ClassNew.cc"><code class="highlighter-rouge">ClassNew</code></a> rewriter consolidates how Sorbet represents class definitions. A line like <code class="highlighter-rouge">Child = Class.new(Parent)</code> would be rewritten as <code class="highlighter-rouge">class Child &lt; Parent; end</code>. This means that Sorbet only needs to know how to type check one class definition syntax rather than two, which simplifies later steps of the type checking pipeline.</p>

<p>My teammates and I applied the same principle to Ruby’s new <code class="highlighter-rouge">Data</code> class. We opened a <a href="https://github.com/sorbet/sorbet/pull/6760">PR on Sorbet</a> that added a new <code class="highlighter-rouge">Data</code> rewriter. This rewriter finds calls to <code class="highlighter-rouge">Data.define</code> and modifies Sorbet’s internal representation of the resulting class to include an initializer, as well as accessor methods for every field passed into the <code class="highlighter-rouge">define</code> method.</p>

<p>You can <a href="https://sorbet.run/?arg=--print&amp;arg=rewrite-tree#%23%20typed%3A%20true%0A%0AMeasure%20%3D%20Data.define%28%3Aamount%2C%20%3Aunit%29">see this rewriter</a> in action on sorbet.run, Sorbet’s online sandbox. By passing in the URL parameters <code class="highlighter-rouge">?arg=--print&amp;arg=rewrite-tree</code>, we can ask Sorbet to print out the results of the rewriter phase of the pipeline, allowing us to visiualize the changes that Sorbet is making to our code under the hood!</p>

<p>If you click the link above, you’ll see that Sorbet rewrites <code class="highlighter-rouge">Measure = Data.define(:amount, :unit)</code> as something closer to:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Measure</span>
  <span class="k">def</span> <span class="nf">amount</span><span class="p">;</span> <span class="k">end</span>
  <span class="k">def</span> <span class="nf">unit</span><span class="p">;</span> <span class="k">end</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">amount</span><span class="o">=</span><span class="kp">nil</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="kp">nil</span><span class="p">);</span> <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Once it knows about methods that will be defined at runtime, Sorbet can accurately type check code that uses Ruby 3.2’s new <code class="highlighter-rouge">Data</code> class!</p>

<h2 id="updating-ruby-core-rbi-files">Updating Ruby Core RBI files</h2>

<p>The last thing my teammates and I needed to do to make Sorbet compatible with Ruby 3.2 was to update Sorbet’s RBI files to reflect the latest changes to Ruby’s core API.</p>

<p>In order to type check methods from Ruby core, Sorbet keeps a <a href="https://github.com/sorbet/sorbet/tree/master/rbi/core">repository of RBI files</a> that define types on every class and module in the Ruby core library. When methods changed in new Ruby versions, Sorbet’s RBIs have to be updated to reflect these changes before Sorbet can begin accurately type checking those methods in our code.</p>

<p>My teammates and I opened a series of PRs against Sorbet that modified the Ruby core RBI files to reflect the changes introduced in Ruby 3.2. Here are some examples:</p>

<ul>
  <li><a href="https://github.com/sorbet/sorbet/pull/6866">Update String RBI for 3.2 changes</a></li>
  <li><a href="https://github.com/sorbet/sorbet/pull/6851">Update Hash#shift RBI</a></li>
  <li><a href="https://github.com/sorbet/sorbet/pull/6773">Add RBIs for Regexp.timeout and Regexp.timeout=</a></li>
</ul>

<hr />

<p>In doing this work, we ensured that Ruby developers at Shopify and in the broader community could leverage all the awesome, new features introduced in Ruby 3.2 while still benefitting from the safety of type checking.</p>

<p>If you’re interested in any of the features mentioned in this article, you can test them out using <a href="https://sorbet.run/">Sorbet’s online sandbox</a>!</p>


    </main>

    <footer>
  <a href="https://github.com/egiurleo">GitHub</a> •
  <a href="https://bsky.app/profile/emilysamp.dev">Bluesky</a> •
  <a href="mailto:emily.samp@icloud.com">Email</a>
</footer>

  </body>
</html>
