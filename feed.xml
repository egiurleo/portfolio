<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://bridgetownrb.com/" version="1.3.4">Bridgetown</generator><link href="https://emilysamp.dev/feed.xml" rel="self" type="application/atom+xml" /><link href="https://emilysamp.dev/" rel="alternate" type="text/html" /><updated>2025-01-15T20:30:52+00:00</updated><id>https://emilysamp.dev/feed.xml</id><title type="html">Emily Samp</title><subtitle>The website of Emily Samp, a software developer and community organizer.</subtitle><author><name>Emily Samp</name></author><entry><title type="html">How to: code review with little or no context</title><link href="https://emilysamp.dev/2025/01/15/code-review/" rel="alternate" type="text/html" title="How to: code review with little or no context" /><published>2025-01-15T00:00:00+00:00</published><updated>2025-01-15T00:00:00+00:00</updated><id>repo://posts.collection/_posts/2025-01-07-code-review.md</id><content type="html" xml:base="https://emilysamp.dev/2025/01/15/code-review/">&lt;p&gt;&lt;em&gt;Note: Thank you to &lt;a href=&quot;https://www.linkedin.com/in/alexcrocha/&quot;&gt;Alex Rocha&lt;/a&gt; for reviewing this post!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Most software teams require code to be opened as a pull request (PR) and reviewed by another teammate before being merged and shipped. This means that, as software developers, we spend a good deal of time reviewing our teammates’ PRs. Often, we will have context on the code we’re reviewing, because we’ve been working alongside our teammates on the same projects. However, there are times when we have to review code with little or no context, whether that’s because we’re joining a new team, onboarding to a new project, or trying to learn about a new domain.&lt;/p&gt;

&lt;p&gt;Reviewing code can be hard at the best of times, but under these circumstances, it can feel impossible. How can you say whether or not code is safe to ship when you literally know nothing about it? How can you spot bugs or inconsistencies in an unfamiliar domain?&lt;/p&gt;

&lt;p&gt;Of course, the only real way to become an effective PR reviewer is to practice over time, but sometimes, you have to review a PR &lt;em&gt;now&lt;/em&gt; to unblock your teammates. When you find yourself in that situation, what do you do?&lt;/p&gt;

&lt;p&gt;In this blog post, I suggest an approach for reviewing PRs that can help you tackle your next PR review with confidence, even if you have little or no context on the code you’re reviewing.&lt;/p&gt;

&lt;h2 id=&quot;a-template-for-pr-reviews&quot;&gt;A template for PR reviews&lt;/h2&gt;

&lt;p&gt;In my opinion, the reason reviewing PRs without context is hard is because we don’t always review strategically. We glance at the PR description and scroll through the code, and our eyes glaze over looking at lines and lines of changes that don’t mean anything to us.&lt;/p&gt;

&lt;p&gt;What if, instead of seeing a PR as lines of code, we see it as a story waiting to be read? What if we approach it with a template that can help us decode that story and make sense of something that might seem confusing at first?&lt;/p&gt;

&lt;p&gt;When reviewing PRs, here are the four questions I ask myself. Once I have at least tried to answer all of them, I know I’ve reviewed the PR to the best of my ability.&lt;/p&gt;

&lt;h3 id=&quot;question-1-why-does-this-pr-exist&quot;&gt;Question 1: Why does this PR exist?&lt;/h3&gt;

&lt;p&gt;This is the very first question I ask myself when looking at a PR. At the highest level, why is this change being made? Some potential answers are:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;It fixes a bug in the code&lt;/li&gt;
  &lt;li&gt;It adds a new feature as part of a project&lt;/li&gt;
  &lt;li&gt;It refactors existing code, enabling future changes&lt;/li&gt;
  &lt;li&gt;It makes the application more accessible&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Notice that the answers don’t have anything to do with &lt;em&gt;how&lt;/em&gt; the code is changed. I would go so far as to say that you &lt;em&gt;shouldn’t&lt;/em&gt; look at the code before trying to answer this question. If your teammates are writing clear PR descriptions (or bug tickets or whatever tool you use to store context like this), then this should be obvious.&lt;/p&gt;

&lt;h3 id=&quot;question-2-how-is-the-code-changed&quot;&gt;Question 2: How is the code changed?&lt;/h3&gt;

&lt;p&gt;Once you understand the &lt;em&gt;why&lt;/em&gt; of the change, you can dig into the &lt;em&gt;how&lt;/em&gt;. What changes are being made to the code to enable the goal stated in question one? Do you agree with the changes? Do you see any points of improvement?&lt;/p&gt;

&lt;p&gt;An important thing to consider at this point is whether there is any proof that the code in the PR does what the author claims it does. Are there unit tests? Can you pull the code locally and look at any UI changes? If you don’t understand all the code in the PR, you can at least decide whether or not it achieves the stated goal by verifying these proofs.&lt;/p&gt;

&lt;h3 id=&quot;question-3-what-other-approaches-could-the-author-have-used-why-did-they-choose-this-one&quot;&gt;Question 3: What other approaches could the author have used? Why did they choose this one?&lt;/h3&gt;

&lt;p&gt;There are always multiple ways to approach any problem. Can you think of any other ways the author might have approached this PR? Is it clear why they chose their approach over the others?&lt;/p&gt;

&lt;p&gt;(This question might be hard to answer, especially if the code is written in a language you’re not familiar with. That’s okay! Spend some time thinking about it anyway. Can you apply your knowledge of general software patterns to this unfamiliar code?)&lt;/p&gt;

&lt;h3 id=&quot;question-4-what-questions-do-i-still-have&quot;&gt;Question 4: What questions do I still have?&lt;/h3&gt;

&lt;p&gt;As you go through the three previous questions, note down anything that confuses you. Maybe you’re wondering why this change is necessary for the project. Maybe there are lines of code you don’t fully understand. Maybe you thought of another approach to the same problem and are wondering if the author had thought of it too. Gather up all these remaining questions and put them in your PR review!&lt;/p&gt;

&lt;h2 id=&quot;if-you-cant-answer-the-above-questions&quot;&gt;If you can’t answer the above questions&lt;/h2&gt;

&lt;p&gt;Even if you follow a systematic approach, you still might encounter a PR that is beyond your experience level, and that’s okay! Here are some more tips for when you’re really stuck.&lt;/p&gt;

&lt;h3 id=&quot;go-commit-by-commit&quot;&gt;Go commit-by-commit&lt;/h3&gt;

&lt;p&gt;If your team has a culture of writing clean, descriptive commits, it might be helpful to review the PR one commit at a time, asking each of the four questions above as you go. Reviewing the code in smaller chunks can make the process more approachable.&lt;/p&gt;

&lt;h3 id=&quot;ask-your-teammates&quot;&gt;Ask your teammate(s)&lt;/h3&gt;

&lt;p&gt;Often, it just makes sense to review the PR with the author or another teammate. Go through the code together and ask them to help you answer the four questions above. Then, ask your teammate about their thought process – what information did they use to answer the questions? Can you learn from their approach?&lt;/p&gt;

&lt;h3 id=&quot;ask-an-llm&quot;&gt;Ask an LLM&lt;/h3&gt;

&lt;p&gt;Sometimes, your teammates just aren’t available to help in cases like this. Maybe you’re working on a tight deadline, or you’re in a different timezone than the rest of your team. Whatever the case may be, an alternative approach is to get support from an LLM like ChatGPT or Claude. You can share the contents of the PR with the LLM and then ask your questions. Even if the results are not 100% accurate, it can at least help you get started.&lt;/p&gt;

&lt;p&gt;(Note: if you are reviewing proprietary code, make sure you aren’t breaking any company or team rules before sharing code with an external tool.)&lt;/p&gt;

&lt;h2 id=&quot;getting-better-over-time&quot;&gt;Getting better over time&lt;/h2&gt;

&lt;p&gt;So far, this article has focused on a short-term approach. However, I think it is just as important to make long-term investments in your team culture and your own skills that will allow you to become a better PR reviewer in the future.&lt;/p&gt;

&lt;h3 id=&quot;create-a-culture-of-clear-pr-descriptions-and-clean-commits&quot;&gt;Create a culture of clear PR descriptions and clean commits&lt;/h3&gt;

&lt;p&gt;Reviewing PRs is a lot easier to do when they have clear, thorough descriptions and small, clean commits. Some teams will already be excelling in this area, while others could probably use some work. If you notice that you and your teammates aren’t prioritizing these forms of asynchronous communication, do something about it! Speak to your manager or your teammates and see if you can shift the culture on your team.&lt;/p&gt;

&lt;h3 id=&quot;read-other-peoples-reviews&quot;&gt;Read other people’s reviews&lt;/h3&gt;

&lt;p&gt;Do you have a teammate whose reviews are always so insightful? You can learn from them by making a point to read their reviews of your and your teammates’ PRs. What kinds of things do they focus on? What changes do they recommend? Those might be areas to focus on in your future PR reviews.&lt;/p&gt;

&lt;h3 id=&quot;keep-track-of-common-review-comments&quot;&gt;Keep track of common review comments&lt;/h3&gt;

&lt;p&gt;As you read your teammates’ PR reviews, try to spot any patterns and write them down. (For example, maybe you notice that your teammate is good at identifying magic numbers or suggesting a specific refactoring pattern.) When it’s time for you to review a PR, refer back to your list and see if you can apply any of your learnings to your current review. Over time, you’ll be able to do this without your list.&lt;/p&gt;

&lt;h3 id=&quot;timebox-yourself&quot;&gt;Timebox yourself&lt;/h3&gt;

&lt;p&gt;At first, reviewing PRs can take a long time. That is totally normal! However, it can be really stressful to feel like you’re not fulfilling other job functions, such as writing code. This is where timeboxing can come in handy. Talk to your manager about how long you should expect to spend on PR reviews every day. Then, sort your list of PRs to review by priority, set a timer, and review as much as you can in the allotted time.&lt;/p&gt;

&lt;p&gt;While you might not get through your whole list of PRs, you will be able to practice the skill of reviewing while balancing the other work you need to do.&lt;/p&gt;

&lt;h3 id=&quot;remember-that-it-gets-easier&quot;&gt;Remember that it gets easier&lt;/h3&gt;

&lt;p&gt;Lastly, remember that reviewing PRs is a skill. Nobody starts out good at it. Even those of us who have been working as developers for years are required to re-up our review abilities as we start new jobs, learn new coding languages, or join new projects. Reviewing PRs might feel hard right now, but that just means you have lots of opportunity to improve. Good luck! I know you can do it.&lt;/p&gt;</content><author><name>Emily Samp</name></author><category term="code-review" /></entry><entry><title type="html">Making Sorbet compatible with Ruby 3.2</title><link href="https://emilysamp.dev/2023/07/13/sorbet-ruby-32/" rel="alternate" type="text/html" title="Making Sorbet compatible with Ruby 3.2" /><published>2023-07-13T00:00:00+00:00</published><updated>2023-07-13T00:00:00+00:00</updated><id>repo://posts.collection/_posts/2023-07-13-sorbet-ruby-32.md</id><content type="html" xml:base="https://emilysamp.dev/2023/07/13/sorbet-ruby-32/">&lt;p class=&quot;post-date&quot;&gt;
  July 13, 2023
&lt;/p&gt;

&lt;p class=&quot;note&quot;&gt;
  ⚠️ &lt;strong&gt;Note&lt;/strong&gt;: This article is cross-posted from Shopify’s &lt;a href=&quot;https://railsatscale.com/2023-06-16-adding-ruby-3-2-support-to-sorbet/&quot;&gt;Rails at Scale blog&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;On the Ruby Developer Experience team here at Shopify, our goal is to deliver a state-of-the-art development experience to Rubyists both at Shopify and in the broader community. This means keeping our tools up-to-date with the most recent versions of Ruby.&lt;/p&gt;

&lt;p&gt;One such tool is &lt;a href=&quot;https://sorbet.org/&quot;&gt;Sorbet&lt;/a&gt;, which is an open source, gradual type checker for Ruby. Sorbet has become a key part of the development experience at Shopify, making it faster and safer for developers to collaborate on a monolith with tens of thousands of Ruby files.&lt;/p&gt;

&lt;p&gt;When we upgraded the Shopify monolith to use Ruby 3.2 at the beginning of 2023, we knew it would require us to make some changes to Sorbet. While upgrading Ruby didn’t break type checking, Sorbet did not yet support all of the &lt;a href=&quot;https://www.ruby-lang.org/en/news/2022/12/25/ruby-3-2-0-released/&quot;&gt;features introduced in this new Ruby version&lt;/a&gt;. If Shopify developers were going to take advantage of the features that came with Ruby 3.2, like the &lt;code class=&quot;highlighter-rouge&quot;&gt;Data&lt;/code&gt; class and anonymous argument forwarding, we would need to make sure Sorbet could accurately type check these usages and report any type checking errors.&lt;/p&gt;

&lt;p&gt;This post is a summary of the work we did to make Sorbet compatible with Ruby 3.2.&lt;/p&gt;

&lt;h2 id=&quot;the-sorbet-pipeline&quot;&gt;The Sorbet pipeline&lt;/h2&gt;

&lt;p&gt;Sorbet statically type checks our code in a process called the &lt;a href=&quot;https://github.com/sorbet/sorbet/blob/master/docs/internals.md#pipeline&quot;&gt;“pipeline”&lt;/a&gt;. The pipeline is made up of different stages, each of which modifies some internal representation of the code before passing it along to the next stage. The ultimate goal of the pipeline is to convert Ruby code into a representation that enables Sorbet to reason about types and identify type checking errors.&lt;/p&gt;

&lt;p&gt;When updating Sorbet to support a new feature in Ruby, it is important to understand which part of the pipeline needs to be changed. When explaining each of the changes my teammates and I implemented, I’ll also give an explanation of the relevant parts of the Sorbet pipeline so you can understand why we approached these problems in the ways we did.&lt;/p&gt;

&lt;p&gt;I hope this overview of Sorbet’s architecture might also encourage you to contribute to Sorbet in the future!&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;anonymous-argument-forwarding-and-the-sorbet-parser&quot;&gt;Anonymous argument forwarding and the Sorbet parser&lt;/h2&gt;

&lt;p&gt;The largest syntax change in Ruby 3.2 was the introduction of &lt;a href=&quot;https://bugs.ruby-lang.org/issues/18351&quot;&gt;anonymous argument forwarding&lt;/a&gt;. This means that in Ruby, it is now possible for a method that takes anonymous arguments or keyword arguments to pass them along to another method, as in this example:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;baz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;quux&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;updating-sorbets-parser&quot;&gt;Updating Sorbet’s parser&lt;/h3&gt;

&lt;p&gt;To support this feature, we first needed to make a change to Sorbet’s parser grammar.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/sorbet/sorbet/blob/master/docs/internals.md#parser&quot;&gt;parser&lt;/a&gt; is the first step in the Sorbet pipeline. Its job is to convert Ruby code into an abstract syntax tree, which is then passed through the rest of the pipeline to be processed and eventually type checked. Without updating the parser, Sorbet wouldn’t even be able to recognize anonymous argument forwarding as valid Ruby code and would raise syntax errors, erroneously telling developers they’d made a mistake!&lt;/p&gt;

&lt;p&gt;To address this, we opened a &lt;a href=&quot;https://github.com/sorbet/sorbet/pull/6910/commits/51808d62a501a97cd60ec6ab9e10aaff821d1e0f&quot;&gt;pull request&lt;/a&gt; that created two new abstract syntax tree nodes representing anonymous argument forwarding. With this change, Sorbet could now represent anonymous argument forwarding in a way that was usable by the following steps in the type checking pipeline.&lt;/p&gt;

&lt;p&gt;We can &lt;a href=&quot;https://sorbet.run/?arg=--print&amp;amp;arg=parse-tree#%23%20typed%3A%20true%0A%0Adef%20foo%28*%29%0A%20%20bar%28*%29%0Aend%0A%0Adef%20baz%28**%29%0A%20%20quux%28**%29%0Aend&quot;&gt;see the parser at work using sorbet.run&lt;/a&gt;, Sorbet’s online sandbox. If we add the URL parameters &lt;code class=&quot;highlighter-rouge&quot;&gt;?arg=--print&amp;amp;arg=parse-tree&lt;/code&gt;, the Sorbet sandbox will print out the results of the parsing step in the pipeline. In these results, we can see that the &lt;code class=&quot;highlighter-rouge&quot;&gt;bar&lt;/code&gt; method receives an argument node of the type &lt;code class=&quot;highlighter-rouge&quot;&gt;ForwardedRestArg&lt;/code&gt;, and the &lt;code class=&quot;highlighter-rouge&quot;&gt;baz&lt;/code&gt; method receives an argument node of the type &lt;code class=&quot;highlighter-rouge&quot;&gt;ForwardedKwrestArg&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;(By the way, if you’re interested in learning more about parsing in Ruby, check out &lt;a href=&quot;https://railsatscale.com//2023-06-12-rewriting-the-ruby-parser/&quot;&gt;Kevin Newton’s recent blog post&lt;/a&gt; about building a new Ruby parser.)&lt;/p&gt;

&lt;h3 id=&quot;desugaring&quot;&gt;Desugaring&lt;/h3&gt;

&lt;p&gt;Updating the parser was the first step in allowing Sorbet to process instances of anonymous argument forwarding, but supporting this feature also required changes to another step in the Sorbet pipeline: the desugarer.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/sorbet/sorbet/blob/master/docs/internals.md#desugar&quot;&gt;desugarer&lt;/a&gt; is the next step in the Sorbet pipeline after the parser; it takes the internal representation built by the parser and cuts it down to a less granular representation, making it easier to work with in later stages of the pipeline.&lt;/p&gt;

&lt;p&gt;To explain what I mean, let’s look at how Sorbet desugars &lt;code class=&quot;highlighter-rouge&quot;&gt;case&lt;/code&gt; statements like this:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pokemon&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;Charmander&apos;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;Squirtle&apos;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;Bulbasaur&apos;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The Sorbet desugarer will take the above &lt;code class=&quot;highlighter-rouge&quot;&gt;case&lt;/code&gt; statement and transform it into an &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt; statement:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;Charmander&apos;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pokemon&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;elsif&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;Squirtle&apos;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pokemon&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;elsif&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;Bulbasaur&apos;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pokemon&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Sorbet does this because it’s simpler to maintain type checking logic for one type of code pattern rather than two. This is why this step of the pipeline is called the “desugarer” – it removes “syntactic sugar,” or syntax that exists only to make the development experience better. If earlier stages of the pipeline can limit the different kinds of syntax Sorbet has to type check, then later stages of the pipeline will contain less type checking logic, making them easier to reason about and maintain.&lt;/p&gt;

&lt;p&gt;We applied a similar principle to desugaring anonymous argument forwarding. Rather than implementing an entire new type checking process for &lt;code class=&quot;highlighter-rouge&quot;&gt;ForwardedRestArg&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;ForwardedKwrestArg&lt;/code&gt; nodes, we used the desugarer to transform them into a representation that Sorbet already knew how to type check!&lt;/p&gt;

&lt;p&gt;Back in 2020, my teammate Alexandre added support for &lt;a href=&quot;https://bugs.ruby-lang.org/issues/16253&quot;&gt;Ruby 2.7’s “forward everything” syntax&lt;/a&gt; to Sorbet (&lt;a href=&quot;https://github.com/sorbet/sorbet/pull/3420&quot;&gt;PR here&lt;/a&gt;). As part of that work, he added logic to the desugarer that would break down forwarded args into three “magic” expressions. As an example, if we had the following code snippet:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;buzz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;biz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The Sorbet desugarer would transform the arguments passed to &lt;code class=&quot;highlighter-rouge&quot;&gt;biz&lt;/code&gt; into something like:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fwd-args&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fwd-kwargs&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fwd-block&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;None of these expressions actually exist in Ruby code – they’re created by the desugarer as a placeholder that Sorbet can type check later on in the pipeline. This is why they’re called “magic.”&lt;/p&gt;

&lt;p&gt;You can see this for yourself on &lt;a href=&quot;https://sorbet.run/?arg=--print&amp;amp;arg=desugar-tree#%23%20typed%3A%20true%0A%0Adef%20buzz%28...%29%0A%20%20biz%28...%29%0Aend&quot;&gt;sorbet.run&lt;/a&gt;. In this case, if we add the &lt;code class=&quot;highlighter-rouge&quot;&gt;?arg=--print&amp;amp;arg=desugar-tree&lt;/code&gt; URL parameters, sorbet.run will show us the output of the desugaring stage, including the magic expressions listed above!&lt;/p&gt;

&lt;p&gt;Because Ruby 3.2’s anonymous argument forwarding feature is so similar to the forward everything syntax, we were able to lean on the work that Alexandre had already done. We updated the desugarer to desugar &lt;code class=&quot;highlighter-rouge&quot;&gt;ForwardedRestArg&lt;/code&gt; nodes (e.g. the argument of &lt;code class=&quot;highlighter-rouge&quot;&gt;bar(*)&lt;/code&gt;) as magic &lt;code class=&quot;highlighter-rouge&quot;&gt;fwd-args&lt;/code&gt; expressions and &lt;code class=&quot;highlighter-rouge&quot;&gt;ForwardedKwrestArg&lt;/code&gt; nodes (e.g. the arguemnt of &lt;code class=&quot;highlighter-rouge&quot;&gt;quux(**)&lt;/code&gt;) as magic &lt;code class=&quot;highlighter-rouge&quot;&gt;fwd-kwargs&lt;/code&gt; expressions.&lt;/p&gt;

&lt;p&gt;You can see how Sorbet desugars anonymous argument forwarding on &lt;a href=&quot;https://sorbet.run/?arg=--print&amp;amp;arg=desugar-tree#%23%20typed%3A%20true%0A%0Adef%20foo%28*%29%0A%20%20bar%28*%29%0Aend%0A%0Adef%20baz%28**%29%0A%20%20quux%28**%29%0Aend&quot;&gt;sorbet.run&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Once we modified the desugarer to convert forwarded anonymous arguments into a representation that Sorbet already knew how to type check, we could rely on the rest of the pipeline to complete the type checking process!&lt;/p&gt;

&lt;p&gt;To see our full set of changes, check out the &lt;a href=&quot;https://github.com/sorbet/sorbet/pull/6910&quot;&gt;pull request that implements support for anonymous argument forwarding in Sorbet&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;supporting-the-new-data-class&quot;&gt;Supporting the new &lt;code class=&quot;highlighter-rouge&quot;&gt;Data&lt;/code&gt; class&lt;/h2&gt;

&lt;p&gt;Another major change in Ruby 3.2 was addition of the &lt;a href=&quot;https://docs.ruby-lang.org/en/3.2/Data.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Data&lt;/code&gt; class&lt;/a&gt;. &lt;code class=&quot;highlighter-rouge&quot;&gt;Data&lt;/code&gt; provides a convenient way to define immutable data structures in Ruby. Here’s an example:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;no&quot;&gt;Measure&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;define&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:unit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Measure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;km&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;amount&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; 100&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;unit&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; &quot;km&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In this example, calling &lt;code class=&quot;highlighter-rouge&quot;&gt;Data.define&lt;/code&gt; creates a new class that has some methods built into it, including a constructor and &lt;code class=&quot;highlighter-rouge&quot;&gt;amount&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;unit&lt;/code&gt; accessor methods. Because these methods are created at runtime, Sorbet wouldn’t be able to know about them statically without a little help. To “teach” Sorbet about these methods, we needed to make a change to a part of the pipeline called the “rewriter.”&lt;/p&gt;

&lt;h3 id=&quot;adding-a-new-rewriter&quot;&gt;Adding a new rewriter&lt;/h3&gt;

&lt;p&gt;The stage of the pipeline after the “desugarer” is the “rewriter” stage. &lt;a href=&quot;https://github.com/sorbet/sorbet/blob/master/docs/internals.md#rewriter&quot;&gt;Rewriters&lt;/a&gt; are very similar to the desugarer, but while the desugarer is broad and covers many types of Ruby syntax, rewriters are specific; they each handle a particular Ruby class or feature.&lt;/p&gt;

&lt;p&gt;For example, Sorbet’s &lt;a href=&quot;https://github.com/sorbet/sorbet/blob/master/rewriter/ClassNew.cc&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ClassNew&lt;/code&gt;&lt;/a&gt; rewriter consolidates how Sorbet represents class definitions. A line like &lt;code class=&quot;highlighter-rouge&quot;&gt;Child = Class.new(Parent)&lt;/code&gt; would be rewritten as &lt;code class=&quot;highlighter-rouge&quot;&gt;class Child &amp;lt; Parent; end&lt;/code&gt;. This means that Sorbet only needs to know how to type check one class definition syntax rather than two, which simplifies later steps of the type checking pipeline.&lt;/p&gt;

&lt;p&gt;My teammates and I applied the same principle to Ruby’s new &lt;code class=&quot;highlighter-rouge&quot;&gt;Data&lt;/code&gt; class. We opened a &lt;a href=&quot;https://github.com/sorbet/sorbet/pull/6760&quot;&gt;PR on Sorbet&lt;/a&gt; that added a new &lt;code class=&quot;highlighter-rouge&quot;&gt;Data&lt;/code&gt; rewriter. This rewriter finds calls to &lt;code class=&quot;highlighter-rouge&quot;&gt;Data.define&lt;/code&gt; and modifies Sorbet’s internal representation of the resulting class to include an initializer, as well as accessor methods for every field passed into the &lt;code class=&quot;highlighter-rouge&quot;&gt;define&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;You can &lt;a href=&quot;https://sorbet.run/?arg=--print&amp;amp;arg=rewrite-tree#%23%20typed%3A%20true%0A%0AMeasure%20%3D%20Data.define%28%3Aamount%2C%20%3Aunit%29&quot;&gt;see this rewriter&lt;/a&gt; in action on sorbet.run, Sorbet’s online sandbox. By passing in the URL parameters &lt;code class=&quot;highlighter-rouge&quot;&gt;?arg=--print&amp;amp;arg=rewrite-tree&lt;/code&gt;, we can ask Sorbet to print out the results of the rewriter phase of the pipeline, allowing us to visiualize the changes that Sorbet is making to our code under the hood!&lt;/p&gt;

&lt;p&gt;If you click the link above, you’ll see that Sorbet rewrites &lt;code class=&quot;highlighter-rouge&quot;&gt;Measure = Data.define(:amount, :unit)&lt;/code&gt; as something closer to:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Measure&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;unit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;initialize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;kp&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;kp&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Once it knows about methods that will be defined at runtime, Sorbet can accurately type check code that uses Ruby 3.2’s new &lt;code class=&quot;highlighter-rouge&quot;&gt;Data&lt;/code&gt; class!&lt;/p&gt;

&lt;h2 id=&quot;updating-ruby-core-rbi-files&quot;&gt;Updating Ruby Core RBI files&lt;/h2&gt;

&lt;p&gt;The last thing my teammates and I needed to do to make Sorbet compatible with Ruby 3.2 was to update Sorbet’s RBI files to reflect the latest changes to Ruby’s core API.&lt;/p&gt;

&lt;p&gt;In order to type check methods from Ruby core, Sorbet keeps a &lt;a href=&quot;https://github.com/sorbet/sorbet/tree/master/rbi/core&quot;&gt;repository of RBI files&lt;/a&gt; that define types on every class and module in the Ruby core library. When methods changed in new Ruby versions, Sorbet’s RBIs have to be updated to reflect these changes before Sorbet can begin accurately type checking those methods in our code.&lt;/p&gt;

&lt;p&gt;My teammates and I opened a series of PRs against Sorbet that modified the Ruby core RBI files to reflect the changes introduced in Ruby 3.2. Here are some examples:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/sorbet/sorbet/pull/6866&quot;&gt;Update String RBI for 3.2 changes&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/sorbet/sorbet/pull/6851&quot;&gt;Update Hash#shift RBI&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/sorbet/sorbet/pull/6773&quot;&gt;Add RBIs for Regexp.timeout and Regexp.timeout=&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;In doing this work, we ensured that Ruby developers at Shopify and in the broader community could leverage all the awesome, new features introduced in Ruby 3.2 while still benefitting from the safety of type checking.&lt;/p&gt;

&lt;p&gt;If you’re interested in any of the features mentioned in this article, you can test them out using &lt;a href=&quot;https://sorbet.run/&quot;&gt;Sorbet’s online sandbox&lt;/a&gt;!&lt;/p&gt;</content><author><name>Emily Samp</name></author><category term="sorbet" /></entry><entry><title type="html">Automated debugging with git bisect and rspec</title><link href="https://emilysamp.dev/2022/11/26/git-bisect/" rel="alternate" type="text/html" title="Automated debugging with git bisect and rspec" /><published>2022-11-26T00:00:00+00:00</published><updated>2022-11-26T00:00:00+00:00</updated><id>repo://posts.collection/_posts/2022-11-26-git-bisect.md</id><content type="html" xml:base="https://emilysamp.dev/2022/11/26/git-bisect/">&lt;p class=&quot;post-date&quot;&gt;
  November 26, 2022
&lt;/p&gt;

&lt;p class=&quot;note&quot;&gt;
  ⚠️ &lt;strong&gt;Note&lt;/strong&gt;: This article is cross-posted from my &lt;a href=&quot;https://dev.to/emilysamp/how-to-run-an-automated-git-bisect-with-rspec-3dm3&quot;&gt;old Dev.to blog&lt;/a&gt; and was originally written in 2021.
&lt;/p&gt;

&lt;p&gt;Debugging is hard. I mean like, really hard.&lt;/p&gt;

&lt;p&gt;As a software engineer, I am constantly expanding my debugging tool belt in an effort to become a faster, more effective debugger. One tool that I’ve known about for a long time but only starting using recently is &lt;strong&gt;git bisect&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;In this blog post, I’ll explain what git bisect is, when it’s useful, and how to use it to automate your debugging process with rspec.&lt;/p&gt;

&lt;h2 id=&quot;what-is-git-bisect&quot;&gt;What is git bisect?&lt;/h2&gt;

&lt;p&gt;When you discover a bug in your code, you’ll often start by asking yourself, “When was this bug introduced, and how?” This is easy enough if your project doesn’t have very many commits – you can go commit by commit and check when the bug was introduced. However, the older your project is, the harder this becomes. What if the bug was introduced 100 commits ago? You can’t be expected to test every single one!&lt;/p&gt;

&lt;p&gt;This is where &lt;code class=&quot;highlighter-rouge&quot;&gt;git bisect&lt;/code&gt; comes in. Git bisect is a feature in &lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt; that helps you quickly find which of your commits introduced a bug using the power of &lt;a href=&quot;https://www.khanacademy.org/computing/computer-science/algorithms/binary-search/a/binary-search&quot;&gt;binary search&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;(It’s not necessary to understand how binary search works in order to use git bisect, but it’s certainly interesting if you want to learn more about it!)&lt;/p&gt;

&lt;h2 id=&quot;how-it-works&quot;&gt;How it works&lt;/h2&gt;

&lt;p&gt;First, you have to find an older commit that does not have the bug. This is called a “good” commit. Then, you find a more recent commit that does have the bug. This is a “bad” commit. You know that the bug was introduced sometime between these two commits, and git bisect will help you find out when.&lt;/p&gt;

&lt;p&gt;Git bisect then performs a binary search, choosing commits in between the ones you specified and testing whether each one is “good” or “bad” (you can automate this step, or test each commit yourself).&lt;/p&gt;

&lt;p&gt;After a few rounds of tests, git bisect will be able to identify which commit created the bug!&lt;/p&gt;

&lt;p&gt;If this still sounds like a lot of work, I have good news – you can provide git bisect with an rspec test so it can automatically determine whether a commit is good or bad. This makes the process almost entirely automatic, and while you go make yourself some coffee, git can let you know which of your commits created that bug you’ve been hunting.&lt;/p&gt;

&lt;h2 id=&quot;scripted-git-bisect&quot;&gt;Scripted git bisect&lt;/h2&gt;

&lt;p&gt;Here are the steps you need to follow to run an automated git bisect with rspec:&lt;/p&gt;

&lt;h3 id=&quot;step-one-start-git-bisect&quot;&gt;Step One: Start git bisect&lt;/h3&gt;

&lt;p&gt;You can tell git to start up a bisect with the following command:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git bisect start
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This puts git into “bisect mode”, which means you won’t be able to do things like commit changes to your code. To exit bisect mode, run &lt;code class=&quot;highlighter-rouge&quot;&gt;git bisect reset&lt;/code&gt; at any time.&lt;/p&gt;

&lt;h3 id=&quot;step-two-find-a-good-commit&quot;&gt;Step Two: Find a “good” commit&lt;/h3&gt;

&lt;p&gt;Look back in your commit history and find one that doesn’t have the bug. Once you’ve found it, run the following command (replace &lt;code class=&quot;highlighter-rouge&quot;&gt;a09c728&lt;/code&gt; with the SHA of your commit):&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git bisect good a09c728
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;step-three-find-a-bad-commit&quot;&gt;Step Three: Find a “bad” commit&lt;/h3&gt;

&lt;p&gt;Find a more recent commit that does have the bug. Pass the commit SHA to the following command (replace &lt;code class=&quot;highlighter-rouge&quot;&gt;b6a0692&lt;/code&gt; with your commit SHA):&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git bisect bad b6a0692
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;step-four-identify-or-write-a-failing-rspec-test&quot;&gt;Step Four: Identify (or write) a failing rspec test&lt;/h3&gt;

&lt;p&gt;In order to automate the git bisect, you’ll have to write a test that fails when the bug is present. You can tell &lt;code class=&quot;highlighter-rouge&quot;&gt;git bisect&lt;/code&gt; to run this test on every commit, which will allow it to automatically determine if a commit is good or bad.&lt;/p&gt;

&lt;p&gt;Here is an example rspec test in the file &lt;code class=&quot;highlighter-rouge&quot;&gt;spec/cat_spec.rb&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;describe&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Cat&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;describe&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;#speak&apos;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;expect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;Cat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;Proxie&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;speak&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;Meow!&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If this test fails, you’ll know that the bug is present, and thus that a commit is “bad”.&lt;/p&gt;

&lt;h3 id=&quot;step-five-run-git-bisect&quot;&gt;Step Five: Run git bisect&lt;/h3&gt;

&lt;p&gt;Now you can run the automated git bisect with the following command:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git bisect run rspec spec/cat_spec.rb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Remember to replace &lt;code class=&quot;highlighter-rouge&quot;&gt;spec/cat_spec.rb&lt;/code&gt; with the path to the test that you wrote in step four. Also remember that you can provide a line number to rspec (if you have many tests in the same file but only want to run one of them). For example, you could run:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git bisect run rspec spec/cat_spec.rb:2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;step-six-profit&quot;&gt;Step Six: Profit&lt;/h3&gt;

&lt;p&gt;Git bisect will test a variety of commits, and it will eventually find the first bad commit, aka the commit that introduced the bug!&lt;/p&gt;

&lt;p&gt;The output will look something like this:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 8b3c38f8680f653f07227f0cef42e54939de448b is the first bad commit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now you can examine that commit and figure out exactly what part of your code introduced the bug!&lt;/p&gt;

&lt;h3 id=&quot;step-seven-clean-up&quot;&gt;Step Seven: Clean up&lt;/h3&gt;

&lt;p&gt;Once you’re done running git bisect, you can restore git to its normal state by running the following command:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git bisect reset
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You can do this at any time during the bisect (even before you run it) to get out of “bisect mode” and get back to your normal workflows.&lt;/p&gt;

&lt;p&gt;That’s all there is to it! With a few commands and a good rspec test, you can simplify what would otherwise be a long and grueling debugging process. Git bisect has come in handy for me, and I hope it helps you out, too!&lt;/p&gt;</content><author><name>Emily Samp</name></author><category term="git," /><category term="productivity," /><category term="ruby," /><category term="rspec" /></entry></feed>